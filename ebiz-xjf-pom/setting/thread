1.可重入锁

　　如果锁具备可重入性，则称作为可重入锁。
	像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，
	而不是基于方法调用的分配。
	举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，
	而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。

　　看下面这段代码就明白了：
class MyClass {
    public synchronized void method1() {
        method2();
    }
     
    public synchronized void method2() {
         
    }
}
 　　上述代码中的两个方法method1和method2都用synchronized修饰了，
 	假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，
 	假如synchronized不具备可重入性，此时线程A需要重新申请锁。
 	但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，
 	这样就会线程A一直等待永远不会获取到的锁。
　　而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。
2.可中断锁
3.公平锁
4.读写锁
--------------------------------------------------------------------------------------------------------------------
在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。
也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。
--------------------------------------------------------------------------------------------------------------------
在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，
以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，
它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，
Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。
也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。

Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。
线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

举个简单的例子：在java中，执行下面这个语句：
i  = 10;
执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。
那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？

--------------------------------------------------------------------------------------------------------------------
1.原子性
　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：
　　请分析以下哪些操作是原子性操作：
	x = 10;         //语句1
	y = x;         //语句2
	x++;           //语句3
	x = x + 1;     //语句4
	咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。
　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。
　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，
	但是合起来就不是原子性操作了。
　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。
 　　所以上面4个语句只有语句1的操作具备原子性。
　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。
　　不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。
	但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。
　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，
	可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，
	那么自然就不存在原子性问题了，从而保证了原子性。
	
2.可见性
　　对于可见性，Java提供了volatile关键字来保证可见性。
　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，
	当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，
	并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。


3.有序性
　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，
	却会影响到多线程并发执行的正确性。
　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，
	很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。
	如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。
	
　　下面就来具体介绍下happens-before原则（先行发生原则）：
程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
　　这8条原则摘自《深入理解Java虚拟机》。

　　这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。
　　下面我们来解释一下前4条规则：
　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。
	注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，
	因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，
	它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。
	事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。
　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，
	后面才能继续进行lock操作。
　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，
	然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。
　　第四条规则实际上就是体现happens-before原则具备传递性。
--------------------------------------------------------------------------------------------------------------------
volatile关键字禁止指令重排序有两层意思：

　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；
	在其后面的操作肯定还没有进行；
　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
　　可能上面说的比较绕，举个简单的例子：

//x、y为非volatile变量
//flag为volatile变量
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
 　　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、
 	语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。
　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、
	语句4、语句5是可见的。
--------------------------------------------------------------------------------------------------------------------
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
 
//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，
而线程2中就使用未初始化的context去进行操作，导致程序出错。
这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。

4.volatile的原理和实现机制
　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。
　　下面这段话摘自《深入理解Java虚拟机》：
　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”
　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；
	即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
　　2）它会强制将对缓存的修改操作立即写入主存；
　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。


synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，
而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，
因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：
　　1）对变量的写操作不依赖于当前值
　　2）该变量没有包含在具有其他变量的不变式中
　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。
　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。

--------------------------------------------------------------------------------------------------------------------
一.对ThreadLocal的理解

　　ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。
	可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。

	先了解一下ThreadLocal类提供的几个方法：
	public T get() { }
	public void set(T value) { }
	public void remove() { }
	protected T initialValue() { }
	get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，
	set()用来设置当前线程中变量的副本，
	remove()用来移除当前线程中变量的副本，
	initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法，
	下面会详细说明。

	至此，可能大部分朋友已经明白了ThreadLocal是如何为每个线程创建变量的副本的：
　　首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，
	这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。
　　初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，
	就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，
	存到threadLocals。
　　然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。

	总结一下：
　　1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；
　　2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，
	因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；
　　3）在进行get之前，必须先set，否则会报空指针异常；
	如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。
--------------------------------------------------------------------------------------------------------------------

	在Java的集合容器框架中，主要有四大类别：List、Set、Queue、Map。
　　List、Set、Queue接口分别继承了Collection接口，Map本身是一个接口。
　　注意Collection和Map是一个顶层接口，而List、Set、Queue则继承了Collection接口，分别代表数组、集合和队列这三大类容器。
　　像ArrayList、LinkedList都是实现了List接口，HashSet实现了Set接口，

	而Deque（双向队列，允许在队首、队尾进行入队和出队操作）继承了Queue接口，
	PriorityQueue实现了Queue接口。
	另外LinkedList（实际上是双向链表）实现了了Deque接口。
	
　　像ArrayList、LinkedList、HashMap这些容器都是非线程安全的。
　　如果有多个线程并发地访问这些容器时，就会出现问题。
　　因此，在编写程序时，必须要求程序员手动地在任何访问到这些容器的地方进行同步处理，这样导致在使用这些容器的时候非常地不方便。
　　所以，Java提供了同步容器供用户使用。
--------------------------------------------------------------------------------------------------------------------
	在Java中，同步容器主要包括2类：
　　1）Vector、Stack、HashTable
　　2）Collections类中提供的静态工厂方法创建的类

　　Vector实现了List接口，Vector实际上就是一个数组，和ArrayList类似，但是Vector中的方法都是synchronized方法，
	即进行了同步措施。
　　Stack也是一个同步容器，它的方法也用synchronized进行了同步，它实际上是继承于Vector类。
　　HashTable实现了Map接口，它和HashMap很相似，但是HashTable进行了同步处理，而HashMap没有。

　　Collections类是一个工具提供类，注意，它和Collection不同，Collection是一个顶层的接口。
	在Collections类中提供了大量的方法，比如对集合或者容器进行排序、查找等操作。
	最重要的是，在它里面提供了几个静态工厂方法来创建同步容器类
